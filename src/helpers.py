from collections import defaultdict
from tqdm import tqdm
import numpy as np
from scipy.sparse import lil_matrix

def create_smali_class(smaliClassName):
    """
    returns the api_calls and apis_per_app for all apps
    """
    smali_class = {}
    smali_class['ClassName'] = smaliClassName.split(' ')[-1][:-1]
    smali_class['Keywords'] = smaliClassName.split(' ')[1:-1]
    smali_class['Metrics'] = {'Reflections':0,'Methods':0,'Invocations':0}
    smali_class['Methods'] = []
    smali_class['Fields'] = []
    smali_class['Loader'] = []
    
    return smali_class

# ---------------------------------------------------------------------
# Driver Functions
# ---------------------------------------------------------------------

def parseSmaliFile(content):
    """
    Parse through all of the smali files and return all relevant information

    :param: content: the opened smali file to be parsed
    """
    smaliClassName = content.readline()
    smali_class = create_smali_class(smaliClassName)
    line = content.readline()
    try:
        while line:
            if line.startswith('.super'):
                smali_class['SuperClass'] = line.split(' ')[1][:-1]
            elif line.startswith('.annotated'):
                pass
            elif line.startswith('.source'):
                smali_class['SourceFile'] = line.split(' ')[1][1:-2]
            elif line.startswith('.implements'):
                smali_class['Implements'] = line.split(' ')[1][:-1]
            elif line.startswith('.field'):
                field = {}
                field['KeyWords'] = line.split('=')[0].split(' ')[1:-1]
                field['Name'] = line.split('=')[0].rstrip().split(' ')[-1].split(':')[0]
                field['Type'] = line.split('=')[0].rstrip().split(' ')[-1].split(':')[1][:-1]
                smali_class['Fields'] += [field]
            elif line.startswith('.method'):
                smali_class['Metrics']['Methods']+= 1
                method = {}
                method['MethodName'] = line.split(' ')[-1][:-1]
                method['Keywords'] = line.split(' ')[1:-1]
                method['Returns'] = line.split(')')[-1]
                method['Parameters'] = line.split('(')[-1].split(')')[0]
                method['Invokes'] = []
                method['LibCalls'] = []
                method['Android API'] = []
                method['ConstStrings'] = []
                method['Dependencies'] = []
                method['Code'] = []
                method['Code'] += [line]
                methodLine = content.readline().lstrip()
                while not methodLine.startswith('.end method'):
                    if "ClassLoader" in methodLine:
                        smali_class["Loader"] += [methodLine]
                    invokes = {}
                    if not methodLine == "\n":
                        method['Code'] += [methodLine]
                    if methodLine.startswith('invoke'):
                        invokes['Type'] = methodLine.split(' ')[0]
                        invokes['Class'] = \
                            methodLine.split('}')[1][1:].split('-')[0]
                        method['Dependencies']\
                             += [methodLine.split('}')[1][1:]
                                .split('-')[0]]
                        invokes['Function'] = \
                            methodLine.split('}')[1].split('>')[1]
                        if (('Landroid' in methodLine)):
                            method["Android API"] += [methodLine]
                        if (('Ljava' in invokes['Class']) or
                                ('Landroid' in invokes['Class']) or
                                ('Ljavax' in invokes['Class'])):
                            method['LibCalls'] += [invokes]
                        else:
                            method['Invokes'] += [invokes]
                        smali_class['Metrics']['Invocations']+= 1
                        if("reflect" in invokes['Function']):
                            smali_class['Metrics']['Reflections']+= 1
                    elif methodLine.startswith('const-string'):
                        method['ConstStrings'] += [methodLine.split('"')[1]]
                    methodLine = content.readline().lstrip()
                method['Code'] += [methodLine]
                smali_class['Methods'] += [method]
            else:
                pass
            line = content.readline()
    except:
        print(line)
        tb = traceback.format_exc()
        print(tb)
        sys.exit(1)
    return smali_class

def show_graph_with_labels(adjacency_matrix):
    """
    draws and dhows a networkX plot with an adjacency matrix as the input

    :param: adjacency_matrix: a numpy matrix object
    """
    rows, cols = np.where(adjacency_matrix == 1)
    edges = zip(rows.tolist(), cols.tolist())
    gr = nx.Graph()
    gr.add_edges_from(edges)
    nx.draw(gr, node_size=15)
    plt.show()

def api_tokenizer(app):
    """
    creates the api_call -> index tokenizing dictionary

    :param: app: a list of filepaths to smali files
    """
    api_calls = defaultdict(int)
    api_idx = 0
    for file in tqdm(app):
        parsed_file = parseSmaliFile(open(file))
        for method in parsed_file['Methods']:
            for api_call in method['Android API']:
                api = api_call.replace('\n','').split(' ')[-1]
                if api not in api_calls:
                    api_calls[api] = api_idx
                    api_idx += 1
    
    return api_calls

def get_meta_data(app):
    """
    gets an app's meta data to be used for EDA

    :param: app: a list of filepaths to smali files
    """
    #Count of methods
    method_count = 0
    #Count of files
    file_count = 0
    #Number of apis
    api_calls = defaultdict(int)
    api_calls_count = 0
    #Number of unique invocations
    invokes = defaultdict(int)
    #Number of unique packages
    packages = defaultdict(int)
    #reflection count
    reflections = 0
    
    for file in tqdm(app):
        file_count += 1
        parsed_file = parseSmaliFile(open(file))
        reflections += parsed_file['Metrics']['Reflections']
        for method in parsed_file['Methods']:
            method_count += 1
            for api_call in method['Android API']:
                #API
                api_calls_count += 1
                api = api_call.replace('\n','').split(' ')[-1]
                if api not in api_calls.keys(): api_calls[api] = 1
                else: api_calls[api] += 1
                #Invokes
                invoke = api_call.split(',')[0].split('}, ')[0]
                if invoke[-1] != '}': invoke += '}'
                if invoke not in invokes.keys(): invokes[invoke] = 1
                else: invokes[invoke] += 1
                package = api_call.split('->')[0].split(' ')[-1]
                if package not in packages.keys(): packages[package] = 1
                else: packages[package] += 1             

                    
    #Sorted dicts
    api_calls = sorted(api_calls.items(), key=lambda item: item[1])
    invokes = sorted(invokes.items(), key=lambda item: item[1])
    packages = sorted(packages.items(), key=lambda item: item[1])
    
    #Unique counts
    api_calls_unique = len(api_calls)
    invokes_unique = len(invokes)
    packages_unique = len(packages)
    
    #Average methods per file
    average_methods_per_file = round(method_count / file_count,2)
    
    meta_data = {'Method Count': [method_count],
                'File Count': [file_count],
                'Average Method Count per File': [average_methods_per_file],
                'Top API Call': [api_calls[-1]],
                'Top Invoke': [invokes[-1]],
                'Top Package': [packages[-1]],
                'Reflections': [reflections],
                'API Call Count':[api_calls_count],
                'Unique API Calls': [api_calls_unique],
                'Unique Invokes': [invokes_unique],
                'Unique Packages': [packages_unique]}
    
    return meta_data