from collections import defaultdict
from tqdm import tqdm
import numpy as np
from scipy.sparse import lil_matrix
from helpers import parseSmaliFile

def b_matrix_calc(app):
    """
    returns the api_calls and code_blocks for an app
    """
    api_calls = defaultdict(int)
    code_blocks = defaultdict(list)
    api_idx = 0
    code_block_idx = 0

    print('Calculating B Matrix...')
    for file in tqdm(app):
        parsed_file = parseSmaliFile(open(file))
        for method in parsed_file['Methods']:
            for api_call in method['Android API']:
                api = api_call.replace('\n','').split(' ')[-1]
                if api not in api_calls:
                    api_calls[api] = api_idx
                    api_idx += 1
                code_blocks[code_block_idx] += [api_calls[api]]
            code_block_idx += 1
    
    return api_calls, code_blocks

# ---------------------------------------------------------------------
# Driver Function
# ---------------------------------------------------------------------

def B_matrix(api_calls, code_blocks):
    """
    Given everything calculated from b_matrix_calc, create the
    matrix object using numpy's lil_matrix

    :param: api_calls: a dictionary of api calls with their index
    :param: code_blocks: a dictionary of each app's code block with api calls in them
    """

    i = len(api_calls) 
    j = len(api_calls) 
    matrix = lil_matrix((i, j), dtype=np.int8)
    idx = []
    for apis in code_blocks.values():
        if len(apis) >= 2:
            pairs = [(apis[i],apis[j]) for i in range(len(apis)) for j in range(i+1,len(apis))]
            idx.extend(pairs)
    idx_ = set(idx)
    for i in list(idx_):
        matrix[i] = 1

    return matrix.toarray()